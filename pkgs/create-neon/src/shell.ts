import { ChildProcess, spawn } from "node:child_process";
import { PassThrough, Readable, Writable } from "node:stream";
import { StringDecoder } from "node:string_decoder";
import readline from "node:readline/promises";
import * as path from "node:path";
import * as fs from "node:fs/promises";

export function readChunks(input: Readable): Readable {
  let output = new PassThrough({ objectMode: true });

  // Raise the default limit on listeners to avoid warnings.
  output.setMaxListeners(20);

  let decoder = new StringDecoder("utf8");
  input.on("data", (data) => {
    output.write(decoder.write(data));
  });
  input.on("close", () => {
    output.write(decoder.end());
    output.end();
  });
  return output;
}

type NpmInitExit = {
  code: number | null;
  signal: string | null;
};

// A child process representing a modified `npm init` invocation:
// - If interactive, the initial prelude of stdout text is suppressed
//   so we can present a modified prelude for create-neon.
// - The process is being run in a temp subdirectory, so any output that
//   includes the temp directory in a path is transformed to remove it.
class NpmInitProcess {
  private _regexp: RegExp;
  private _child: ChildProcess;

  constructor(interactive: boolean, args: string[], cwd: string, tmp: string) {
    this._regexp = new RegExp(tmp + ".");
    this._child = spawn("npm", ["init", ...args], {
      stdio: ["inherit", "pipe", "inherit"],
      shell: true,
      cwd,
    });
    this.filterStdout({ interactive }).then(() => {});
  }

  exit(): Promise<NpmInitExit> {
    let resolve: (exit: NpmInitExit) => void;
    const result: Promise<NpmInitExit> = new Promise((res) => {
      resolve = res;
    });
    this._child.on("exit", (code, signal) => {
      resolve({ code, signal });
    });
    return result;
  }

  async filterStdout(opts: { interactive: boolean }) {
    // We'll suppress the `npm init` interactive prelude text,
    // in favor of printing our own create-neon version of the text.
    let inPrelude = opts.interactive;

    for await (const chunk of readChunks(this._child.stdout!)) {
      const lines = (chunk as string).split(/\r?\n/);
      if (opts.interactive && inPrelude) {
        // If there's a prompt, it'll be at the end of the data chunk
        // since npm init will have flushed stdout to block on stdin.
        if (!lines[lines.length - 1].match(/^[a-z ]+:/)) {
          // We're still in the prelude so suppress all the lines and
          // wait for the next chunk of stdout data.
          continue;
        }

        // Suppress the prelude lines up to the prompt.
        lines.splice(0, lines.length - 1);
        inPrelude = false;
      }

      // Print out all the lines.
      lines.forEach((line, i) => {
        // Remove the temp dir from any paths printed out by `npm init`.
        process.stdout.write(line.replace(this._regexp, ""));
        if (i < lines.length - 1) {
          process.stdout.write("\n");
        }
      });
    }
  }
}

// Standard order of package.json keys generated by `npm init`.
const NPM_INIT_KEYS = [
  "name",
  "version",
  "description",
  "main",
  "scripts",
  "author",
  "license",
];

function sort(json: any): any {
  // First copy the keys in the order specified in NPM_INIT_KEYS.
  let next = NPM_INIT_KEYS.filter((key) => json.hasOwnProperty(key))
    .map((key) => [key, json[key]])
    .reduce((acc, [key, val]) => Object.assign(acc, { [key]: val }), {});

  // Then copy any remaining keys in the original order.
  return Object.assign(next, json);
}

export async function npmInit(
  interactive: boolean,
  args: string[],
  cwd: string,
  tmp: string
): Promise<any> {
  const child = new NpmInitProcess(interactive, args, cwd, tmp);
  const { code, signal } = await child.exit();

  if (code === null) {
    process.kill(process.pid, signal!);
  } else if (code !== 0) {
    process.exit(code);
  }

  const filename = path.join(cwd, "package.json");

  const sorted = sort(JSON.parse(await fs.readFile(filename, "utf8")));

  await fs.writeFile(filename, JSON.stringify(sorted, undefined, 2) + "\n");

  return sorted;
}

export type Parser<T> = (v: string) => T;

export function oneOf<T extends {}>(opts: T): Parser<T[keyof T]> {
  return (v: string) => {
    for (const key in opts) {
      if (v === key) {
        return opts[key];
      }
    }
    throw new Error("parse error");
  };
}

export interface Question<T> {
  prompt: string;
  parse: Parser<T>;
  default: T;
  error?: string;
}

export class Dialog {
  private _rl: readline.Interface | undefined;

  constructor() {
    this._rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });
  }

  private rl(): readline.Interface {
    if (!this._rl) {
      throw new Error("dialog already ended");
    }
    return this._rl;
  }

  end() {
    this.rl().close();
    this._rl = undefined;
  }

  async ask<T>(opts: Question<T>): Promise<T> {
    while (true) {
      try {
        const answer = (
          await this.rl().question(
            `neon ${opts.prompt}: (${String(opts.default)}) `
          )
        ).trim();
        return answer === "" ? opts.default : opts.parse(answer);
      } catch (_ignored) {
        if (opts.error) {
          console.log(`Sorry, ${opts.error}`);
        }
      }
    }
  }
}
